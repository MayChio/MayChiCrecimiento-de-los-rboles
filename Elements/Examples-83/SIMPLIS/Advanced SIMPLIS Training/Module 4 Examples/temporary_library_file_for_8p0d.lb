** Copyright SIMetrix Technologies/SIMPLIS Technologies Inc
** 2010 All rights reserved
** SIMetrix/SIMPLIS release 8.0 Model Library
**
** These models are believed to be accurate but neither
** SIMetrix Technologies Ltd. nor SIMPLIS Technologies Inc.
** offer any guarantee as to their fitness for any purpose nor do they
** accept any responsibility for damage caused directly or indirectly
** by their use.
**
**
** Models in this library use the netlist preprocessor
**
** This line marks this library as a system library
** Models in this library will not appear in the
** "User Models" or "New Models" categories
.systemlib
**

.SIMULATOR SIMetrix

** Electrolytic capacitor - Level 1 to 3
.subckt ELEC_CAP_L13 1 9 vars: LEVEL=1 CC=1000u RSH_CC=1meg IC=0 RESR=10m LESL=100n USEIC=0
*#LABELS ,Level (1-3):INTEGER:1|3,Capacitance,Leakage Resistance,Initial Condition,ESR (Level>1),ESL (Level=3),Use Initial Condition:BOOL

.if {LEVEL==1}
    .var capnode = 1
.else
    .var capnode = 2
.endif

.if {USEIC}
    C1 {capnode} 9 {CC} IC={IC} BRANCH=1
.else
    C1 {capnode} 9 {CC}
.endif

RSH {capnode} 9 {RSH_CC}

.if {LEVEL==2}
    RESR 1 2 {RESR}
.else
    .if {LEVEL==3}
        RESR 2 3 {RESR}
        LESL 1 3 {LESL}
    .endif
.endif

.ends

** Electrolytic capacitor - Level 4 to 5
.subckt ELEC_CAP_L45 1 9 vars: LEVEL=4 CC_LF=1000u CC_HF=1u RSH_CC_LF=1meg RSH_CC_HF=1meg RESR_LF=50m RESR_HF=10m LESL=100n IC=0 USEIC=0
*#LABELS ,Level (4-5):INTEGER:4|5,Capacitance LF,Capacitance HF,Leakage Res. LF,Leakage Res. HF,ESR LF,ESR HF,ESL (Level=5),Initial Condition,Use Initial Condition:BOOL

 .NODE_MAP P 1
 .NODE_MAP N 9

.if {LEVEL==4}
    .var node = 1
.else
    .var node = 4
    LESL 1 4 {LESL}
.endif

.if {USEIC}
    CC_LF 2 9 {CC_LF} IC={IC} BRANCH=1
    CC_HF 3 9 {CC_HF} IC={IC} BRANCH=1
.else
    CC_LF 2 9 {CC_LF}
    CC_HF 3 9 {CC_HF}
.endif

RSH_CC_LF 2 9 {RSH_CC_LF}
RSH_CC_HF 3 9 {RSH_CC_HF}

RESR_LF {node} 2 {RESR_LF}
RESR_HF {node} 3 {RESR_HF}

.ends


*** Multi-Level Cap Introduced in Version 8.0

.SIMULATOR SIMETRIX

.subckt MULTI_LEVEL_CAP_QTY 1 9 vars:
+ C=47u
+ C_TOL=0
+ C_DIST='None'
+ RLK=1Meg
+ RLK_TOL=0
+ RLK_DIST='None'
+ ESR=3m
+ ESR_TOL=0
+ ESR_DIST='None'
+ ESL=500p
+ ESL_TOL=0
+ ESL_DIST='None'
+ ESL_SHUNT=31.4
+ USE_IC=0
+ IC=0
+ USE_QTY=0
+ QTY=1
+ LEVEL=2

.IF { C_DIST != 'None' && C_DIST != 'Gauss' && C_DIST != 'Truncated\sGauss' && C_DIST != 'Uniform' && C_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Capacitor Distribution Function: { C_DIST }"
.ENDIF

.IF { RLK_DIST != 'None' && RLK_DIST != 'Gauss' && RLK_DIST != 'Truncated\sGauss' && RLK_DIST != 'Uniform' && RLK_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Capacitor Distribution Function: { RLK_DIST }"
.ENDIF

.IF { ESR_DIST != 'None' && ESR_DIST != 'Gauss' && ESR_DIST != 'Truncated\sGauss' && ESR_DIST != 'Uniform' && ESR_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Capacitor Distribution Function: { ESR_DIST }"
.ENDIF

.IF { ESL_DIST != 'None' && ESL_DIST != 'Gauss' && ESL_DIST != 'Truncated\sGauss' && ESL_DIST != 'Uniform' && ESL_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Capacitor Distribution Function: { ESL_DIST }"
.ENDIF

.VAR INNODE=9
*** Add quantity parts
.IF {USE_QTY==0}
    .VAR M=1
.ELSE
    .IF {QTY>0}
    	.VAR M = {QTY}
    .ELSE
        .VAR M=1
    .ENDIF
.ENDIF

*** Determine internal nodes
.IF {LEVEL<2}
    .VAR CAPNODE = { INNODE }
.ELSE
    .VAR CAPNODE = 2
.ENDIF

.IF { LEVEL == 3 }
	.VAR ESRNODEN = 3
.ELSE
	.VAR ESRNODEN = { INNODE }
.ENDIF

*** Capacitor
.IF { C_DIST == 'Gauss' }
	CAP 1 {CAPNODE} { chr(123) & C & '*Gauss(' & C_TOL/100 & ')' & chr(125) } M={M}
.ELSE
	.IF { C_DIST == 'Truncated\sGauss' }
		CAP 1 {CAPNODE} { chr(123) & C & '*GaussLim(' & C_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { C_DIST == 'Uniform' }
			CAP 1 {CAPNODE} { chr(123) & C & '*Unif(' & C_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { C_DIST == 'Worst\sCase' }
				CAP 1 {CAPNODE} { chr(123) & C & '*Wc(' & C_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				CAP 1 {CAPNODE} { C } M={M}
			.ENDIF
		.ENDIF
	.ENDIF
.ENDIF

*** Add IC?
.IF {USE_IC}
{ '+' } IC={IC} BRANCH=1
.ENDIF

*** Leakage
.IF {LEVEL > 0 && RLK > 0}

	*** Leakage
	.IF { RLK_DIST == 'Gauss' }
		RLK 1 {CAPNODE} { chr(123) & RLK & '*Gauss(' & RLK_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { RLK_DIST == 'Truncated\sGauss' }
			RLK 1 {CAPNODE} { chr(123) & RLK & '*GaussLim(' & RLK_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { RLK_DIST == 'Uniform' }
				RLK 1 {CAPNODE} { chr(123) & RLK & '*Unif(' & RLK_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				.IF { RLK_DIST == 'Worst\sCase' }
					RLK 1 {CAPNODE} { chr(123) & RLK & '*Wc(' & RLK_TOL/100 & ')' & chr(125) } M={M}
				.ELSE
					RLK 1 {CAPNODE} { RLK } M={M}
				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF
.ENDIF

.IF {LEVEL>=2}

	*** ESR
	.IF { ESR_DIST == 'Gauss' }
		RESR 2 {ESRNODEN} { chr(123) & ESR & '*Gauss(' & ESR_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { ESR_DIST == 'Truncated\sGauss' }
			RESR 2 {ESRNODEN} { chr(123) & ESR & '*GaussLim(' & ESR_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { ESR_DIST == 'Uniform' }
				RESR 2 {ESRNODEN} { chr(123) & ESR & '*Unif(' & ESR_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				.IF { ESR_DIST == 'Worst\sCase' }
					RESR 2 {ESRNODEN} { chr(123) & ESR & '*Wc(' & ESR_TOL/100 & ')' & chr(125) } M={M}
				.ELSE
					RESR 2 {ESRNODEN} { ESR } M={M}
				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF
.ENDIF

.IF {LEVEL==3}

	*** ESL
	.IF { ESL_DIST == 'Gauss' }
		LESL 3 {INNODE} { chr(123) & ESL & '*Gauss(' & ESL_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { ESL_DIST == 'Truncated\sGauss' }
			LESL 3 {INNODE} { chr(123) & ESL & '*GaussLim(' & ESL_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { ESL_DIST == 'Uniform' }
				LESL 3 {INNODE} { chr(123) & ESL & '*Unif(' & ESL_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				.IF { ESL_DIST == 'Worst\sCase' }
					LESL 3 {INNODE} { chr(123) & ESL & '*Wc(' & ESL_TOL/100 & ')' & chr(125) } M={M}
				.ELSE
					LESL 3 {INNODE} { ESL } M={M}
				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF

	*** ESL Shunt Resistance
	RESL 3 {INNODE} { ESL_SHUNT } M={M}

.ENDIF

.ENDS MULTI_LEVEL_CAP_QTY


.SIMULATOR SIMETRIX

*** Multi-Level Lossy Inductor Introduced in Version 8.0
.subckt MULTI_LEVEL_LOSSY_IND_QTY 1 9 vars:
+ L=1u
+ L_TOL=0
+ L_DIST='None'
+ ESR=500u
+ ESR_TOL=0
+ ESR_DIST='None'
+ R_SHUNT=62.8319k
+ USE_IC=1
+ IC=0
+ USE_QTY=0
+ QTY=1
+ LEVEL=1

.NODE_MAP P 1
.NODE_MAP N 9

.IF { L_DIST != 'None' && L_DIST != 'Gauss' && L_DIST != 'Truncated\sGauss' && L_DIST != 'Uniform' && L_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Inductor Distribution Function: { L_DIST }"
.ENDIF

.IF { ESR_DIST != 'None' && ESR_DIST != 'Gauss' && ESR_DIST != 'Truncated\sGauss' && ESR_DIST != 'Uniform' && ESR_DIST != 'Worst\sCase' }
	.ERROR "Invalid Value for Inductor Distribution Function: { ESR_DIST }"
.ENDIF

.VAR INNODE=9
*** Add quantity parts
.IF {USE_QTY==0}
    .VAR M=1
.ELSE
    .IF {QTY>0}
    	.VAR M = {QTY}
    .ELSE
        .VAR M=1
    .ENDIF
.ENDIF

*** Determine internal nodes
.IF {LEVEL<1}
    .VAR IND_NODE = { INNODE }
.ELSE
    .VAR IND_NODE = 2
.ENDIF

*** Inductor
.IF { L_DIST == 'Gauss' }
	L_IND 1 {IND_NODE} { chr(123) & L & '*Gauss(' &  L_TOL/100 & ')' & chr(125) } M={M}
.ELSE
	.IF { L_DIST == 'Truncated\sGauss' }
		L_IND 1 {IND_NODE} { chr(123) & L & '*GaussLim(' &  L_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { L_DIST == 'Uniform' }
			L_IND 1 {IND_NODE} { chr(123) & L & '*Unif(' &  L_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { L_DIST == 'Worst\sCase' }
				L_IND 1 {IND_NODE} { chr(123) & L & '*Wc(' &  L_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				L_IND 1 {IND_NODE} { L } M={M}
			.ENDIF
		.ENDIF
	.ENDIF
.ENDIF

*** Add IC?
.IF {USE_IC}
{ '+' } IC={IC/M} BRANCH=0
.ENDIF

*** Inductor Shunt Resistance
R_SHUNT 1 {IND_NODE} { R_SHUNT }

*** ESR
.IF {LEVEL>0}

	*** ESR
	.IF { ESR_DIST == 'Gauss' }
		RESR 2 {INNODE} { chr(123) & ESR & '*Gauss(' & ESR_TOL/100 & ')' & chr(125) } M={M}
	.ELSE
		.IF { ESR_DIST == 'Truncated\sGauss' }
			RESR 2 {INNODE} { chr(123) & ESR & '*GaussLim(' & ESR_TOL/100 & ')' & chr(125) } M={M}
		.ELSE
			.IF { ESR_DIST == 'Uniform' }
				RESR 2 {INNODE} { chr(123) & ESR & '*Unif(' & ESR_TOL/100 & ')' & chr(125) } M={M}
			.ELSE
				.IF { ESR_DIST == 'Worst\sCase' }
					RESR 2 {INNODE} { chr(123) & ESR & '*Wc(' & ESR_TOL/100 & ')' & chr(125) } M={M}
				.ELSE
					RESR 2 {INNODE} { ESR } M={M}
				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF

.ENDIF

.ENDS MULTI_LEVEL_LOSSY_IND_QTY
