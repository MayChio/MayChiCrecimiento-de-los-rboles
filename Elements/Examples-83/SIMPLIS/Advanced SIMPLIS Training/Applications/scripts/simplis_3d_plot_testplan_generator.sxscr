***
*** simplis_3d_plot_testplan_generator_version.sxscr
***

*** Author: Chris Bridge, SIMPLIS Technologies
*** Customer: Intel
*** Version : 5.2

*** Unsupported user script which creates testplan files for generating 3D plots using SIMetrix/SIMPLIS DVM.
*** This version exploits Multi-Step analysis in SIMetrix/SIMPLIS DVM Version 8.0.

***
*** debug flag
Let debug = GetOption( 'Simplis3DTestplanDebug' ) != 'false'

*** find paths relative to the schematic
Let bits = SplitPath( ReadSchemProp( 'path' ) )
Let path = bits[0] & bits[1]

*** floating point error check
Let TOL = 1E-15

*** special characters
let tab = EscapeString( '\t' )
Let nl = Chr( 10 )
Let sq = Chr(39)

*** edit the parameters
Let paramNames=''
Let defaults=''
Let labels=''
Let numParams = 0
Let error = 0

Let tabs = ''
Let groups = ''
Let descriptions = ''
get_labels_and_parameters_tab_value_dialog @paramNames @defaults @labels @numParams @error @tabs @groups @descriptions

if !error then

	Let values = MakeString(numParams)

	for idx=0 to numParams-1
		Let values[idx] = (PropValues(paramNames[idx]))[0]
		if values[idx]=='' then
			Let values[idx] = defaults[idx]
		endif
	next idx

	Let values = TabValueDialog( tabs , groups , labels , values , descriptions )
	if Length(values)=0 then
		exit script
	endif

	*** CDB - 09/09/2015
	*** If a user has "LABEL" type of controls, those have a parameter name but no value.
	*** LABEL type controls are always at the end of the array of controls.
	*** Thus the numParams is incorrect when writing the values to the symbol.
	*** We instead end the writing of parameters at the length of the values array.
	for idx=0 to Length(values)-1

		** Strip white space. Amongst other things, this allows additional
		** text to be appended to list box entries for comment purposes
		Let values[idx] = (Parse(values[idx], ' '))[0]

		Prop /hidenew {paramNames[idx]} {values[idx]}
	next idx

endif  

*** min and max current
Let currents = Vector( 2 )
Let currents[0] = Val( PropValue( 'LOAD_CURRENT_MIN' ) )
Let currents[1] = Val( PropValue( 'LOAD_CURRENT_MAX' ) )
Let init_file_name = bits[2] & '_3d_istart_' & currents[0] &'_A'

*** slew rate
Let slew_rate = Val( PropValue( 'LOAD_SLEW_RATE' ) )

*** frequency variable, decade sweep.
Let freq_start_stop = Vector( 2 )
Let freq_start_stop[0] = Val( PropValue( 'LOAD_FREQ_START' ) )
Let freq_start_stop[1] = Val( PropValue( 'LOAD_FREQ_STOP' )  )

Let number_freqs = [ Val( PropValue( 'LOAD_FREQ_N_FREQ1' ) ) ,
+                   Val( PropValue( 'LOAD_FREQ_N_FREQ2' ) ) , 
+                   Val( PropValue( 'LOAD_FREQ_N_FREQ3' ) ) ]

Let n_cycles = [ Val( PropValue( 'LOAD_NUMBER_OF_CYCLES1' ) ) ,
+               Val( PropValue( 'LOAD_NUMBER_OF_CYCLES2' ) ) , 
+               Val( PropValue( 'LOAD_NUMBER_OF_CYCLES3' ) ) ]

Let n_delay_cycles = [ Val( PropValue( 'LOAD_NUMBER_OF_CYCLES_DELAY1' ) ) ,
+                     Val( PropValue( 'LOAD_NUMBER_OF_CYCLES_DELAY2' ) ) , 
+                     Val( PropValue( 'LOAD_NUMBER_OF_CYCLES_DELAY3' ) ) ]

*** pop flag...
Let do_pop = Val( PropValue( 'INCLUDE_POP' ) ) == 1
Let num_cores = PropValue( 'NUM_CORES' )

*** error check
if ( ( currents[1] - currents[0] ) < TOL ) then
	Let MessageBox( [ 'The final current is not greater than the initial current.' , 'Error: Invalid Currents' ] , [ 'Ok' , 'warn' ] )
	exit script
endif

if ( slew_rate < TOL ) then
	Let MessageBox( [ 'The slew rate is way too small.' , 'Error: Invalid Slew Rate' ] , [ 'Ok' , 'warn' ] )
	exit script
endif

Let rise = ( currents[1] - currents[0] ) / slew_rate
Let fall = ( currents[1] - currents[0] ) / slew_rate

*** try to find control symbols
Let controlhandles = MakeString( 0 )
Let controlsymbols = MakeString( 0 )
simplis_dvm_advanced_util_find_control_handle @controlhandles @controlsymbols

Let controlhandle = controlhandles[0]
Let load_refs = PropValues2( 'DVM_LOADS' , -1 , 'handle' , controlhandle )
Let src_refs = PropValues2( 'DVM_DCSOURCES' , -1 , 'handle' , controlhandle )

*** get the number of plot points...
Let psp_npt_str = PropValues2( 'ANALYSIS_PSP_NPT' , -1 , 'handle' , controlhandle )
if !StringLength( psp_npt_str ) then
	*** try harder...
	Let lines = GetF11Lines( 'spice' )
	Let opts = SIMPLISSearchIdx( SelectColumns( lines , 0 , ' ' ) , '.OPTIONS' )
	for i = 0 to Length( opts ) - 1
		Let psp_npt_str = ParseparameterString( lines[opts[i]] , 'PSP_NPT' , 'read' , '' , 'allowquoted' )
		if StringLength( psp_npt_str ) then
			Exit For
		endif
	next i
endif

*** Prompt the user...
if !StringLength( psp_npt_str ) then
	Let psp_npt_str = InputSchem( '12000' , 'Error: Couldn''t find number of plot points' )
	if !Length( psp_npt_str ) then
		Exit Script
	endif
endif

*** parse the source and load property on commas
Let src_refs = Parse( src_refs , ',' )
Let load_ref = Parse( load_refs , ',' )

if length( load_ref ) > 1 then
	Echo { 'Multiple output loads found, using the first managed load.' }
	Let load_ref = load_ref[0]
endif

*** Headers
Let headers =[ '*?@ label' , 
+			'analysis'    , 
+			'analysis'    , 
+			'analysis'    , 
+			'preprocess'  , 
+			'objective'   ,
+			'load'        ,
+			'postprocess' 
+			]


Let headers_setup =[ '*?@ label' , 
+			'analysis'    , 
+			'var( Freq , 10k )'    , 
+			'var( Duty , 50 )'    , 
+			'preprocess'  , 
+			'objective'   ,
+			'load'        ,
+			'postprocess' 
+			]


*** add generateinitfile, includeinitfile
if do_pop then
	Let headers     = JoinStringArray( headers , [ 'generateinitfile' , 'includeinitfile' ] )
	Let headers_setup = JoinStringArray( headers_setup , [ 'generateinitfile' , 'includeinitfile' ] )
endif

Let headers     = JoinStringArray( headers , [ 'Change( I1.AXIS_TYPE_I , grid )' ] )
Let headers_setup = JoinStringArray( headers_setup , [ 'Change( I1.AXIS_TYPE_I , grid )' ] )


*** for each input source, disable the probes
for i = 0 to length( src_refs ) - 1
	Let headers = JoinStringArray( headers , 'Change( ' & src_refs[i] & '.DISABLED_V , 1 )' )
	Let headers = JoinStringArray( headers , 'Change( ' & src_refs[i] & '.DISABLED_I , 1 )' )
	Let headers_setup = JoinStringArray( headers_setup , 'Change( ' & src_refs[i] & '.DISABLED_V , 1 )' )
	Let headers_setup = JoinStringArray( headers_setup , 'Change( ' & src_refs[i] & '.DISABLED_I , 1 )' )
next i

*** Calculate Frequencies/start/stop times - it's really complicated now
Let frequencies = Vector(10000)
Let start_times = Vector(10000)
Let stop_times  = Vector(10000)

Let current_freq = freq_start_stop[0]
Let frequencies[0] = current_freq
Let start_times[0] = n_delay_cycles[0]/frequencies[0]
Let stop_times[0]  = start_times[0] + n_cycles[0]/frequencies[0] 

if debug then
	ClearMessageWindow
	Echo
	Echo /box { 'Debug Report for 3-D Testplan Generation' }
	Echo
	Echo { 'Calculated : ' & FormatNumber( current_freq , 4 ) & ' using n_freq : ' & FormatNumber( number_freqs[0] , 6 ) & ' per decade i : 0' }
endif

Let i = 1
Let dec = 0 ; *** decade state machine
Let flags = 0 * Vector( 3 )
while current_freq <= freq_start_stop[1]

	*** select n_freq
	if i <= number_freqs[0] then
		Let n_freq = number_freqs[0]
		Let k = 0
		
		if flags[0] == 0 then
			Let flags[0] = 1
			Let dec = 1
			if debug then
				Echo ; Echo { 'Decade : 1 ' }
			endif
		endif
		
	elseif i <= number_freqs[0] + number_freqs[1] then
	
		Let n_freq = number_freqs[1]

		Let k = number_freqs[1] - number_freqs[0]
		if flags[1] == 0 then
			Let flags[1] = 1
			Let dec = 2
			if debug then
				Echo ; Echo { 'Decade : 2 ' }
			endif
		endif
		
	elseif i > number_freqs[0] + number_freqs[1] then
	
		Let n_freq = number_freqs[2]

		 Let k = 2 * number_freqs[2] - number_freqs[1] - number_freqs[0]
		
		if flags[2] == 0 then
			Let flags[2] = 1
			Let dec = 3
			if debug then
				Echo ; Echo { 'Decade : 3+' }
			endif
		endif
		
	endif
	
	Let current_freq =  frequencies[0] * 10 ^ ((i+k)/n_freq) 
	Let frequencies[i] = current_freq
	
	Let start_times[i] = n_delay_cycles[dec-1]/frequencies[i]
	Let stop_times[i]  = start_times[i] + n_cycles[dec-1]/frequencies[i] 

	if debug then
		Echo { 'Calculated : ' & SprintfNumber( '%.1f Hz' , current_freq ) & ' using n_freq : ' & FormatNumber( n_freq , 6 ) & ' per decade i : ' & i }
	endif
	
	if frequencies[i] > freq_start_stop[1] then
		Let frequencies[i] = freq_start_stop[1]
		Let frequencies = Range( frequencies , 0 , i )
		Let start_times = Range( start_times , 0 , i )
		Let stop_times  = Range( stop_times , 0 , i )
		
		exit while
	endif
	
	let i = i + 1
	
endwhile

if debug then
	Echo
	Echo { 'Total n_freq : ' & Length( frequencies ) }
	Echo 
	Show start_times stop_times
endif

*** Calculate Duty Cycles
Let duty_cycles1 = Vector( 1000 )
Let duty_cycles2 = Vector( 1000 )
Let duty_cycles3 = Vector( 1000 )

Let min_duties = [ Val( PropValue( 'LOAD_DUTY_MIN1' ) ) ,
+                 Val( PropValue( 'LOAD_DUTY_MIN2' ) ) , 
+                 Val( PropValue( 'LOAD_DUTY_MIN3' ) ) ]

Let max_duties = [ Val( PropValue( 'LOAD_DUTY_MAX1' ) ) ,
+                 Val( PropValue( 'LOAD_DUTY_MAX2' ) ) , 
+                 Val( PropValue( 'LOAD_DUTY_MAX3' ) ) ]

Let step_duties = [ Val( PropValue( 'LOAD_DUTY_STEP1' ) ) ,
+                  Val( PropValue( 'LOAD_DUTY_STEP2' ) ) , 
+                  Val( PropValue( 'LOAD_DUTY_STEP3' ) ) ]

if debug then
	Echo
	Show min_duties max_duties step_duties
endif

*** first decade
Let duty_cycles1 = Vector( step_duties[0] ) * (max_duties[0]-min_duties[0])/(step_duties[0]-1) + min_duties[0]
 
*** second decade
Let duty_cycles2 = Vector( step_duties[1] ) * (max_duties[1]-min_duties[1])/(step_duties[1]-1) + min_duties[1]

*** third and higher decades
Let duty_cycles3 = Vector( step_duties[2] ) * (max_duties[2]-min_duties[2])/(step_duties[2]-1) + min_duties[2]

if debug then
	show step_duties
endif

*** the number of calculated frequencies
Let num_calc_freq = Vector( 3 )
Let num_calc_freq[0] = 1 + number_freqs[0]
Let num_calc_freq[1] = number_freqs[1]
Let num_calc_freq[2] = Length( frequencies ) - num_calc_freq[1] - num_calc_freq[0]

Let num_tests = 0
for i = 0 to 2
	Let num_tests = num_tests + num_calc_freq[i] * step_duties[i]
	if debug then
		Echo { 'for decade : ' & i + 1 & ' num_ tests : ' & num_calc_freq[i] * step_duties[i] }
	endif
next i

if debug then
	Echo { 'number of tests : ' & num_tests }
endif

Let output_string = MakeString( 0 )
Let setup_output_string = MakeString( 0 )

Let output_string = JoinStringArray( output_string , SimplisDVMSyncBuckUtilJoin( headers , tab ) )
Let setup_output_string = JoinStringArray( setup_output_string , SimplisDVMSyncBuckUtilJoin( headers_setup , tab ) )

*** the analysis and label for this test
if do_pop then

	Let objective = 'Steady-State'
	
	Let output_string = JoinStringArray( output_string , [ '***' , '*** POP Simulation' ] )
	Let setup_output_string = JoinStringArray( setup_output_string , [ '***' , '*** POP Simulation' ] )

	*** we need to calculate some load timing...
	Let width = 1/frequencies[0] * 0.01 * duty_cycles1[0] - 0.5 * rise - 0.5 * fall

	*** figure out a load entry, used for all tests

	*** load with non-parameterized frequency and duty cycle
	Let load = 'Pul( OUTPUT:1 , ' & currents[0] & ' , ' & currents[1] & ' , ' & Chr( 123 ) & frequencies[0] & Chr(125) & ' , ' & rise & ' , ' & fall & ' , ' & Chr(123) & '(0.01/' & frequencies[0] & ')*' & 50 & '-' & rise & Chr(125) & ' , IDLE_IN_POP=1 TIME_DELAY=' & Chr(123) & '0.5/' & frequencies[0] & Chr(125) &' )'
	
	Let first_test_entries = [
+							'3D Plot Generation|POP' ,
+							'' ,
+							'' ,
+							'' ,
+							'./scripts/simplis_3d_plot_validate_preprocess.sxscr' ,
+							objective ,
+							load , 
+							'./scripts/simplis_3d_plot_validate_postprocess.sxscr' 
+ ]

	Let first_test_entries = JoinStringArray( first_test_entries , [ init_file_name , '' ] )
	
	for i = 0 to length( src_refs ) - 1
		Let first_test_entries = JoinStringArray( first_test_entries , [ '' , '' ] )
	next i
	
	*** Let first_test_entries = JoinStringArray( first_test_entries , [ './scripts/simplis_3d_plot_validate.sxscr' ] )
	
	Let output_string = JoinStringArray( output_string , SimplisDVMSyncBuckUtilJoin( first_test_entries , tab ) )
	Let setup_output_string = JoinStringArray( setup_output_string , SimplisDVMSyncBuckUtilJoin( first_test_entries , tab ) )

endif

Let stop_decade = 1
*** we can now generate the output file as a string array output_string.
if freq_start_stop[1] / freq_start_stop[0] > 10 then
	Let stop_decade = 2
endif

if freq_start_stop[1] / freq_start_stop[0] > 100 then
	Let stop_decade = 3
endif

Let exit_for = 0
Let max_freq_in_dec = 0 * Vector( 3 )
for dec = 1 to stop_decade

	if exit_for then
		exit for
	endif
	
	*** create temporary vectors for duty_cycles, identify the start and stop indexes.
	if dec == 1 then
	
		Let start_idx = 0
		Let stop_idx = num_calc_freq[0] - 1
		
		*** create a temp duty cycle vector
		let duty_cycles = duty_cycles1
		
		if debug then
			Echo ; Echo { 'Generating output' }
			Echo { 'Decade : 1' }
			Echo { 'start_freq : ' & frequencies[start_idx] }
			Echo { 'stop_freq  : ' & frequencies[stop_idx] }
		endif
		
	elseif dec == 2 then
	
		Let start_idx = stop_idx + 1
		Let stop_idx = start_idx + num_calc_freq[1] - 1
		
		*** create a temp duty cycle vector
		let duty_cycles = duty_cycles2
		
		if debug then
			Echo 
			Echo { 'Decade : 2' }
			Echo { 'start_freq : ' & frequencies[start_idx] }
			Echo { 'stop_freq  : ' & frequencies[stop_idx] }
		endif

	elseif dec == 3 then

		Let start_idx = stop_idx + 1
		Let stop_idx = length( frequencies ) - 1 
		
		*** create a temp duty cycle vector
		let duty_cycles = duty_cycles3
		
		if debug then
			Echo
			Echo { 'Decade : 3+' }
			Echo { 'start_freq : ' & frequencies[start_idx] }
			Echo { 'stop_freq  : ' & frequencies[stop_idx] }
			Echo 
		endif
		
	endif
	
	*** validate all frequencies/duties
	Let max_freq = frequencies[0] ; *** initialize to start frequency
	for freq_idx = start_idx to stop_idx
		
		if exit_for then
			exit for
		endif

		*** loop through duty cycles
		for duty_idx = 0 to length( duty_cycles ) - 1

			if exit_for then
				exit for
			endif
			
			*** calculate pulse width.
			Let width = 1/frequencies[freq_idx] * 0.01 * duty_cycles[duty_idx] - 0.5 * rise - 0.5 * fall
			
			*** test width is positive, but less than the period. Use 1p as floating point rounding error.
			Let ltz = width < 1p 
			Let gtp = ( rise + fall + width ) > 1/frequencies[freq_idx] - 1p
			
			if ltz || gtp then
				
				*** this is the first frequency where the table will not be square.
				Let max_freq = frequencies[freq_idx-1]
				Let frequencies = Range( frequencies , 0, freq_idx-1 )
				Let exit_for = 1
				
			else

				Let max_freq = frequencies[freq_idx]
			
			endif
			
		next duty_idx
		
	next freq_idx
	
	if exit_for then
		Let max_freq_in_dec[dec-1] = 1
	endif

next dec

if debug then

	Echo
	Echo { 'Maximum frequency found is : ' & max_freq }
	Echo
	Echo { 'Maximum frequency occurs in decades:' }
	show max_freq_in_dec
	Echo
	Echo { 'Now for pulse widths at this frequency...' }
	
	for duty_idx = 0 to length( duty_cycles ) - 1
		
		*** calculate pulse width.
		Let width = 1/max_freq * 0.01 * duty_cycles[duty_idx] - 0.5 * rise - 0.5 * fall
		
		Echo { 'Duty : ' & duty_cycles[duty_idx] & ' pulse width : ' & width }
		*** test width is positive, but less than the period.
		Let ltz = width < 0 
		Let gtp = ( rise + fall + width ) > 1/max_freq
		
		if ltz || gtp then
			
			Echo { 'Something has gone terribly wrong!' }

		endif
		
	next duty_idx
	
	Echo
	show frequencies
endif

Let output_string = JoinStringArray( output_string , [ '***' , '*** Transient Simulations' ] )
Let setup_output_string = JoinStringArray( setup_output_string , [ '***' , '*** Transient Simulations' ] )

*** output tests to string arrays
for dec = 1 to stop_decade

	*** the nuber of points per decade
	Let n_freqs = number_freqs[dec-1]

	*** the starting frequency
	if dec == 1 then
		Let start_freq = frequencies[0]*10^(dec-1)
	else
		Let start_freq = frequencies[0]*10^(dec-1)*10^( 1/number_freqs[dec-1])
		Let n_freqs = number_freqs[dec-1]
	endif
	
	*** the ending frequency
	Let end_freq = frequencies[0] * 10^dec

	if max_freq_in_dec[dec-1] then

		*** dump special
		Let end_freq = max_freq
		if dec > 1 then
			Let start_freq = frequencies[0]*10^(dec-1)*10^( 1/number_freqs[dec-1])
		endif

	endif

	Let ms_analysis_freq = 'Multi-Step( Freq , Decade , ' & n_freqs & ' , ' & start_freq & ' , ' & end_freq & ' , NUM_CORES=' & num_cores & ' )'
	Let ms_analysis_duty = 'Multi-Step( Duty , Linear , ' & step_duties[dec-1] & ' , ' & min_duties[dec-1] & ' , ' & max_duties[dec-1] & ' )'

	if debug then
		Echo
		Echo { 'start frequency : ' & start_freq }
		Echo { 'end frequency   : ' & end_freq }
		Show ms_analysis_freq
		Show ms_analysis_duty
	endif
	
	
	if dec == 1 then
		Let label = '3D Plot Generation|1st Decade'
	elseif dec == 2 then
		Let label = '3D Plot Generation|2nd Decade'
	elseif dec == 3 then
		Let label = '3D Plot Generation|3rd and Higher Decades'
	endif

	Let stop_cycles = n_cycles[dec-1] + n_delay_cycles[dec-1]
	Let delay_cycles = n_delay_cycles[dec-1]
	
	*** analysis entry
	let analysis = '.OPTIONS PSP_NPT=' & psp_npt_str & '\n.TRAN ' & Chr(123) & ' ' & stop_cycles & ' / Freq ' & Chr(125) & ' ' & Chr(123) & ' ' & delay_cycles & ' / Freq ' & Chr(125)
	
	let setup_analysis = '.OPTIONS PSP_NPT=' & psp_npt_str & '\n.TRAN ' & Chr(123) & ' ' & stop_cycles & ' / ' & start_freq & Chr(125) & ' ' & Chr(123) & ' 0 / ' & start_freq & ' ' & Chr(125)
	
	*** figure out a objective entry
	Let objective = 'PulseLoad( OUTPUT:1 , ' & currents[0] & ' , ' & currents[1] & ' , ' & currents[0] & ' , OVERWRITE_ANALYSIS=0 )'
	
	Let load = 'Pul( OUTPUT:1 , ' & currents[0] & ' , ' & currents[1] & ' , ' & Chr( 123 ) & 'Freq' & Chr(125) & ' , ' & rise & ' , ' & fall & ' , ' & Chr(123) & '(0.01/Freq)*Duty-' & rise & Chr(125) & ' , IDLE_IN_POP=1 TIME_DELAY=' & Chr(123) & '0.5/Freq' & Chr(125) &' )'
	
	Let test_entries = [
+					label ,
+					analysis        ,
+					ms_analysis_freq ,
+					ms_analysis_duty ,
+					'./scripts/simplis_3d_plot_validate_preprocess.sxscr' ,
+					objective  ,
+					load      , 
+					'./scripts/simplis_3d_plot_validate_postprocess.sxscr'
+ ]

	Let setup_test_entries = [
+					 '3D Plot Generation|' & Str( start_freq ) ,
+					setup_analysis        ,
+					Str( start_freq ) ,
+					'50' ,
+					'./scripts/simplis_3d_plot_validate_preprocess.sxscr' ,
+					objective  ,
+					load      , 
+					'./scripts/simplis_3d_plot_validate_postprocess.sxscr' 
+ ]

	if do_pop then
		Let test_entries = JoinStringArray( test_entries , [ '' , init_file_name ] )
		Let setup_test_entries = JoinStringArray( setup_test_entries , [ '' , init_file_name ] )
	endif
	
	Let output_string = JoinStringArray( output_string , SimplisDVMSyncBuckUtilJoin( test_entries , tab ) )
	Let setup_output_string = JoinStringArray( setup_output_string , SimplisDVMSyncBuckUtilJoin( setup_test_entries , tab ) )
	
	if max_freq_in_dec[dec-1] then
		Exit For
	endif
	
next dec

Let output_string = JoinStringArray( output_string , '***' )
*** Let setup_output_string = JoinStringArray( setup_output_string , '***' )
let summary_test = [ '3D Plot Generation|Summarize' , 'nosimulation' , '' ]

for i = 0 to length( src_refs ) - 1
	Let summary_test = JoinStringArray( summary_test , [ '' , '' ] )
next i

Let summary_test = JoinStringArray( summary_test , './scripts/simplis_3d_post_process_summary.sxscr' )

Let output_string = JoinStringArray( output_string , SimplisDVMSyncBuckUtilJoin( summary_test , tab ) )

*** figure out a filename
Let output_filename =  bits[2] & '_f_start_' & FormatNumber( freq_start_stop[0] , 3 ) & '_f_stop_' & FormatNumber( max_freq , 3 ) & '_I_' & FormatNumber( currents[0] , 3 ) & 'A_to_' & FormatNumber( currents[1] , 3 ) & 'A_' & Iff( do_pop , 'pop_' , 'nopop_' ) & 'v_5'

Let output_filename = SubStString( output_filename , '.' , 'p' , 'all' )
Let output_filename = output_filename & '.testplan'

if !ExistDir(  path & '/testplans' ) then
	MakeTree {  path & '/testplans' }
endif

cd { path & '/testplans' }

Let output_filename = GetUserFile( 'testplan files|*.testplan' , 'testplan' , '' , output_filename )
Let file_bits = SplitPath( output_filename )
Let setup_output_filename = file_bits[0] & file_bits[1] & file_bits[2] & '_setup.testplan'

if !StringLength( output_filename ) then
	CD { path }
	Exit Script
endif

Let vi = VersionInfo()
Let version = vi[5]

Let header_str = [ '*** Auto-generated testplan for generating 3D plots' ,
+				'*** Version: 5.2' ,
+				'*** Date: ' & date() ,
+				'*** Time: ' & time() , 
+				'*** Using SIMetrix/SIMPLIS Version: ' & version ,
+				'***' ,
+				'*** Start Frequency = ' & freq_start_stop[0] , 
+				'*** Stop Frequency  = ' & max_freq , 
+				'***' ,
+				'*** Frequency steps per decade : 1st=' & number_freqs[0] & ', 2nd=' & number_freqs[1] & ', 3rd=' & number_freqs[2] ,
+				'*** Number of pulse cycles     : 1st=' &  n_cycles[0] & ', 2nd=' & n_cycles[1] & ', 3rd=' & n_cycles[2] ,
+				'*** Data gathering delay       : 1st=' &  n_delay_cycles[0] & ', 2nd=' & n_delay_cycles[1] & ', 3rd=' & n_delay_cycles[2] ,
+				'***' ,
+				'*** Load Current               : min=' & currents[0] & ' , max=' & currents[1] ,
+				'***' ,
+				'*** Duty Cycle Decade #1       : min=' & min_duties[0] & ', max=' & max_duties[0] & ', nsteps=' & step_duties[0], 
+				'*** Duty Cycle Decade #2       : min=' & min_duties[1] & ', max=' & max_duties[1] & ', nsteps=' & step_duties[1], 
+				'*** Duty Cycle Decade #3+      : min=' & min_duties[2] & ', max=' & max_duties[2] & ', nsteps=' & step_duties[2] , 
+				'***' ]

*** read file, join it up
Let output_string = JoinStringArray( header_str , output_string )
Let setup_output_string = JoinStringArray( Range( header_str , 0 , 5 ) , setup_output_string )

Let full_tp_filename = (SplitPath( output_filename ))[2] & (SplitPath( output_filename ))[3]

Let setup_output_string[0] = '*** Auto-generated Setup Testplan for : ' & full_tp_filename

*** dump to file.
if !CanOpenFile( setup_output_filename , 'write' ) || !CanOpenFile( output_filename , 'write' ) then
	Let MessageBox( [ 'The output file(s) are open in another application. Close the files and Click Ok.' , 'Error: Cannot write output files' ] , [ 'Ok' , 'error' ] )
endif

show /plain /file { setup_output_filename } setup_output_string
show /plain /file { output_filename } output_string

CD { path }

Echo
Echo { 'Created testplan : ' & setup_output_filename }
Echo { 'Created testplan : ' & output_filename }
Echo
