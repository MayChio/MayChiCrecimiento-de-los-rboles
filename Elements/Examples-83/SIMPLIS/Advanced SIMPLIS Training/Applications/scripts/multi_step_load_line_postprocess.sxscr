***
*** multi_step_load_line_postprocess.sxscr
***
Arguments @retval label report_dir log_file controlhandle

*** tab character
Let tab = EscapeString( '\t' )

*** read control symbol values for load line resistance and tolerances
Let vnom = PropValues2( 'OUTPUT1_NOM' , -1 , 'handle' , controlhandle )
Let rnom = PropValues2( 'OUTPUT1_LOAD_LINE' , -1 , 'handle' , controlhandle )
Let ptol = PropValues2( 'OUTPUT1_PTOL' , -1 , 'handle' , controlhandle )
Let ntol = PropValues2( 'OUTPUT1_NTOL' , -1 , 'handle' , controlhandle )

*** read control symbol for first load ref des
Let load_refs = PropValues2( 'DVM_LOADS' , -1 , 'handle' , controlhandle )

*** error check
if !StringLength( vnom ) || !StringLength( rnom ) || !StringLength( ptol ) || !StringLength( ntol ) || !StringLength( load_refs ) then
	
	if !StringLength( vnom ) then
		Echo { 'Couldn''t find value for control symbol property: OUTPUT1_NOM' }
	endif
	
	if !StringLength( rnom ) then
		Echo { 'Couldn''t find value for control symbol property: OUTPUT1_LOAD_LINE' }
	endif
	
	if !StringLength( ptol ) then
		Echo { 'Couldn''t find value for control symbol property: OUTPUT1_PTOL' }
	endif
	
	if !StringLength( ntol ) then
		Echo { 'Couldn''t find value for control symbol property: OUTPUT1_NTOL' }
	endif
	
	if !StringLength( load_refs ) then
		Echo { 'Couldn''t find value for control symbol property: DVM_LOADS' }
	endif
	Exit Script

else

	Let load_ref = (Parse( load_refs , ',' ))[0]
	Let load_name = PropValues2( 'LOAD_NAME' , -1 , 'ref' , load_ref )

endif

*** first we get all dirs, reports, labels from logs for this DVM execution:
let dirs    = ''
Let reports = ''
Let labels  = ''
simplis_dvm_advanced_util_get_test_dirs_reports_labels_from_log log_file @dirs @reports @labels

*** these are the scalar names we are looking for
Let targets = [ 'AVG(V' & load_name & ')' , 'AVG(I' & load_name & ')' ]

********************************************************************************
***                                                                          ***
***                   Collect Data from dvm_mslog.log files                  ***
***                                                                          ***
********************************************************************************

*** string arrays for the vector data
Let voltages_str = MakeString(0)
Let currents_str = MakeString(0)

*** loop through directories
for dir = 0 to length( dirs ) - 1

	*** file name
	let file = dirs[dir] & '\dvm_mslog.log'
	
	*** does it exist?
	if CanOpenFile( file ) then
	
		*** hoover it up into an array
		Let file_lines = ReadFile( file )
		
		*** keys are in the first column
		Let first_idx = -1
		Let second_idx = -1
		
		Let col = SelectColumns( file_lines , 0 , tab )
		Let first_idx = Search( col , 'Run #' )
		if first_idx > -1 then
			Let second_idx = Search( Range( col , first_idx ) , '***' )
		endif
		
		
		*** slice it...
		if first_idx > -1 && second_idx > -1 then
			
			Let second_idx = second_idx + first_idx
			
			Let lines = Range( file_lines , first_idx , second_idx - 1 )
			
			*** search out our target data in header rows
			Let idxs = search( Parse( lines[0] , tab ) , targets )

			*** Must have all indexes, otherwise data will not line up with the freq , duty parameters.
			*** data can be in random column order, and the script finds it. But all data must be present in the file.
			*** the script echos an error if all are not found, but proceeds to the next file.
			if Minimum( idxs > -1 ) then
				Let voltages_str  = JoinStringArray( voltages_str , Range( SelectColumns( lines , idxs[0] , tab ) , 1 ) )
				Let currents_str  = JoinStringArray( currents_str , Range( SelectColumns( lines , idxs[1] , tab ) , 1 ) )
			else
				*** handle error
				Echo
				Echo { 'Error: Couldn''t find all scalars in file.' }
				Echo { 'In particular, Report with label : ' & labels[dir] }
				Echo { 'Has the following missing scalars:' }
				
				for i= 0 to Length( targets ) - 1
					If idxs[i] < 0 then
						Echo { targets[i] }
					endif
				next i
			endif
		else
			Echo
			Echo { 'Error: Couldn''t find start and end tags in dvm_mslog.log file.' }
			Echo { 'Opening tag is "Run #" and closing tag is an empty string.' }
			Echo { file }
		endif
	elseif StrStr( label , 'POP' ) < -1 || StrStr( label , 'Summarize' ) < -1 then
		*** warn for any run which is not a POP or Summary directory.
		Echo
		Echo { 'Error: Couldn''t open dvm_mslog.log file.' }
		Echo { file }
	endif
next i

*** convert strings to reals
Let yes = Vector( length( voltages_str ) )
Let exes = Vector( length( voltages_str ) )

for i = 0 to length( exes ) - 1
	Let yes[i] = Val( voltages_str[i] )
	Let exes[i] = Val( currents_str[i] )
next i

Let sorted_vector = SimplisDVMSyncBuckUtilSortRealXYVectorByRef( XY( yes , exes ) )

*** generate the load line curve
Plot /newsheet

SelectCurve /unselect /all
Curve /select /name { 'DVM Load Line' } /xlabel { 'Load Current' } /xunit { 'A' } /ylabel { 'Output Voltage' } /yunit { 'V' } sorted_vector
Let cid = GetSelectedCurves()
SetGraphAnnoProperty { cid } { 'RGBColour' } { '16711680' }
SetGraphAnnoProperty { cid } { 'ShowPoints' } { 'true' }
SetGraphAnnoProperty { GetGraphObjPropValue( cid , 'Graph' ) } { 'ProbeId' } { 'DVM Load Line' }
SelectCurve /unselect /all

if length( cid ) then

	Let y_axis_id = GetCurveAxis( cid )
	Let x_axis_id = GetXAxis()
	
	SelectCurve /unselect /all
	Curve /select /newgrid /name { 'DVM Load Line Res' } /yunit { 'Ohm' } -diff(sorted_vector)
	SetGraphAnnoProperty { GetSelectedCurves() } { 'RGBColour' } { '32768' }
	
	Let xmin = Val( GetGraphObjPropValue( x_axis_id , 'min' ) )
	Let xmax = Val( GetGraphObjPropValue( x_axis_id , 'max' ) )
	
	SelectCurve /unselect /all
	Curve /select /axisid { y_axis_id } /name { 'DVM Pos Limit' } Xy( [ vnom * ( 1 + 0.01 * ptol ) - xmin * rnom , vnom * ( 1 + 0.01 * ptol ) - xmax * rnom ] , [ xmin , xmax ] )
	SetGraphAnnoProperty { GetSelectedCurves() } { 'RGBColour' } { '255' }
	
	SelectCurve /unselect /all
	Curve /select /axisid { y_axis_id } /name { 'DVM Neg Limit' } Xy( [ vnom * ( 1 - 0.01 * ntol ) - xmin * rnom , vnom * ( 1 - 0.01 * ntol ) - xmax * rnom ] , [ xmin , xmax ] )
	SetGraphAnnoProperty { GetSelectedCurves() } { 'RGBColour' } { '255' }
	
	SelectCurve /unselect /all
	
endif

Let SimplisDVMAdvancedUtilMeasurementPromoteGraph( 'DVM Load Line' , log_file )